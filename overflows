virtuelle Speicherverwaltung (32-Bit)
--------------------------------------------------------------------------------
Man arbeitet mit dem flat memory model bzw. dem protected Mode. Die
Zusammenarbeit zwischen dem Prozessor und dem Betriebsystemkern ermöglicht,
dass jedem Prozess einen Adressraum von 4GB (2^32) zur verfügung steht. Die
virtuelle Speicherverwaltung arbeitet nicht mehr kombiniert mit einer Segment-
und einer Offsetadresse (DOS), sondern man benutzt eine einzige 32-Bit große
(Offset-)Adresse für den kompletten Adressraum. Der Systemkern setzt beim Start
einer Awendung einen 4GB umfassenden Adressraum. Dies ist auch der Fall,
wenn gar keine 4 GB RAM zur verfügung stehen. Eine Anwendung belegt nur so
viel Speicher, wie der Programmcode und die zugehörigen Daten benötigen. Eine
Anwendung kann später weiteren Speicher anfordern, dies ist der virtuellen
Speichervarwaltung zu verdanken. Verwaltet wird die virtuelle
Speicherverwaltung durch den Systemkern und basiert auf einem grundlegenden
Mechanismus der Speicheradressierung des Prozessors. Oft ist nicht der gesamte
virtuelle Speicher einer Anwendung physikalisch verfügbar, da sich eine
Anwedung in der Regel nur in Teilen des Codes oder der Daten bewegt. So ist es
Möglich das man Teile des Arbeitspeichers auf einer Festplatte auslagern kann.
Zugriffe auf ausgelagerten Speicher werden vom Prozessor abgefangen und
ausgelagerte Teile werden von ihm erst wieder in den Arbeitsspeicher geladen.
Die Anwendung selbst bekommt von diesem Vorgang nichts mit. Damit das Ein- und
Auslagern möglichst effizent ist, teilt der Prozessor den virtuellen Speicher
in 4 KB große Abschnitte, sogenannte Pages, auf. Wann immer Maschinencode
auf einen Adressraum zugreifen will, berechnet der Prozessor erst ein mal aus
der Adresse die Nummer der Page. Er bedient sich dazu der Page-Tabellen auch
Page-Directorys genannt.  Über sie wird der Adressraum Stück für Stück auf
Pages im physikalischen Speicher verteilt. Der Prozessor gibt das Format dieser
Tabellen vor aber sie werden vom Betriebssystem verwaltet. In dem jeweiligen
Eintrag der Page-Tabelle schaut der Prozessor, ob sich die Page im
physikalischen Speicher befindet. Ein Eintrag in einer Page-Tabelle enthält für
diesen Zweck verschiedene Flags, die unter anderem definieren, auf welche Art
auf die Pages zugegriffen werden darf (read-only, …). Sollte Speicher
ausgelagert sein, so wird dies dem Systemkern gemeldet, welcher sich um das
Nachladen der Pages kümmert. Ist der komplette physikalische Speicher in
Benutzung, so muss müssen erst andere Pages ausgelagert werden. Was ein
Programm an durchgängigen Adressraum sieht erstreckt sich so in Wirklichkeit
über viele Pages, welche an ganz unterschiedlichen Stellen im physikalischen
Speicher existieren. Der Speicher einer Anwendung kann bis zu Unkenntlichkeit
fragmentiert sein, doch es wird ihr verborgen bleiben, weil Sie keinen
Speicherzugriff ausführen kann, ohne das der Prozessor dies bemerken würde. Da
manche ausgelagerte Daten eventuell zeitnah wieder benötigt werden, versucht
das Betriebssystem dies zu erahnen und läd manche Daten schon wieder in den
Speicher, bevor versucht wurde auf diese zu zugreifen. Nicht der komplette
Adressraum von 4GB steht aber der Anwendung zur Verfügung. Pages von Bibliotheken
z.B. können in mehreren Anwendungen zur verfügung stehen und eine Instanz einer
Bibliothek benötigt auch einen Datenbereich. Adressen größer 3GB sind dem
Systemkern vorbehalten, somit ist anzunehmen, das wenn die CPU in diesen
Adressraum wechselt, sie auch von Ring-3 zu Ring-0 wechselt.

Paging
--------------------------------------------------------------------------------
Paging ist ein intergraler Bestandteil des Protected Mode und seit dem 80386
verfügbar. Für den Einsatz des Paging-Mechanismus ist das PG-Bit im
Control-Register 0 (CR0) des Prozessors verantwortlich. Dieses Bit steht auf 0
nach dem das System im Real-Mode startet, hier werden lineare Speicheradressen
direkt auf physikalische Adressen abgebildet und Paging findet noch nicht statt.
Schalte das Betriebssystem den Prozessor in den Protected-Mode, so setzt es
dieses Bit auf 1. Jede Adresse, die der Prozessor bezüglich eines
Maschinenbefehls verarbeitet, wird in diesem Modus erst einer Page zugeordnet.
Ein Speicherzugriff wird ab jetzt auf eine Page umgeleitet. Die Größe einer
Page beträgt 4 kB und jede Page beginnt an einer durch 4 kB teilbaren
physikalischen Adresse. Der Adressraum wird dadurch in 2^20 verschiedene Pages
aufgeteilt, die jeweils 2^12 Byte (4 kB) umfassen. Die Ausrichtung auf 4 kB
ermöglicht, dass die untere 12 Bitgrenze dafür sorgt, dass lineare Adressen
und physikalische Adressen identisch sind. Sie stellen eine Art Offset der Page
da. Die oberen 20 Bit der linearen Adresse werden für die Nummerierung der Page
verwendet. Diese 20 Bit werden isoliert und als Index in der Page-Table
verwendet, aus welcher die physikalische Adresse entnommen wird.  Die Einträge
in der Page-Table sind 32 Bit breit, es werden aber nur 20 Bit benötigt, denn
sie muss an einer durch 4 kB teilbaren physikalischen Speicherstelle beginnen.
Egal welche Page man nimmt, die unteren 12 Bit des Index sind deshalb immer 0.
Somit werden dort die verschiedenen Flags untergebracht, welche z.B. definieren
ob eine Page ausgelagert ist. Damit für eine komplette Page-Table keine
kompletten 4 MB verwendet werden müssen, wurde der Mechanismus von Intel etwas
verfeinert...

Heap-Prozeß


Bufferoverflow


Stackoverflow


Heapoverflow


Integeroverflow


DEP


Angriffe DEP


ASLR


PIE-Flag


Angriffe ASLR


Stack Smashing Protector (ehemals ProPolice)


Stack Guard


Syscall-Filtering (https://en.wikipedia.org/wiki/Seccomp)


Container (Chroot, LXC, Jails, ...)


Sandboxing (Apps, Browser, Java, ...)


Jailbreak


Finden von Overflows


Vermeiden von Overflows
